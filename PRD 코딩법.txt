##########################################################################################
##########################################################################################


  # PRD: Folder Memo (Final Specification)

## 0. 문서 개요 (Document Info)
* **목적:** Windows 파일 탐색기(Explorer)와 연동되는 오버레이 메모 애플리케이션의 기능 명세.
* **개발 방법론:** **PRD-주석 연계 개발 (PRD-Comment Linked Development)**
    * 본 문서의 요구사항 번호(예: `2.1.3.`)는 코드 주석의 참조 기준이 된다.
    * 코드는 기능 구현 시 해당 PRD 번호를 명시하여 의도를 설명해야 한다.

---

## 1. 프로젝트 개요 (Overview)
* **1.1. 제품 정의:** 탐색기 창에 포스트잇처럼 붙어 다니는 **폴더별 전용 메모 오버레이**.
* **1.2. 핵심 가치:**
    * **Seamless:** 탐색기와 완벽한 일체감 (위치, Z-Order 동기화).
    * **Context-Aware:** 현재 폴더에 맞는 메모 자동 로드/생성.
    * **Eco-Friendly:** Event-Driven 구조를 통한 리소스 효율성 극대화 (CPU 0%).

---

## 2. 핵심 동작 및 뷰 (Core Behavior & View)

### 2.1. 탐색기 인식 및 매칭 (Detection & Matching)
* **2.1.1. 대상 인식:** 실행 중인 모든 `CabinetWClass` (파일 탐색기) 윈도우를 감지 대상으로 한다.
* **2.1.2. 1:1 오버레이 매핑:** 감지된 각 탐색기 윈도우마다 독립적인 메모 오버레이 인스턴스를 하나씩 생성하여 매핑한다.
* **2.1.3. 실시간 신규 감지:** 프로그램 실행 중 새로 열리는 탐색기 창을 감지하여 오버레이를 부착한다. (Event Hook 활용)
* **2.1.4. 탭(Tab) 유동성 지원:** 탐색기 탭의 분리(새 창) 또는 병합 상황에서도 해당 경로에 맞는 메모 연결이 끊기지 않아야 한다.

### 2.2. 화면 배치 및 순서 (Layout & Z-Order)
* **2.2.1. 상대적 위치 고정 (Anchor):** 메모 오버레이는 항상 매칭된 탐색기 윈도우 내부(Client Area)의 **우측 하단**에 위치한다. 탐색기 이동/크기 변경 시 동기화된다.
* **2.2.2. 계층적 Z-Order (Sandwich Stacking):**
    * 메모는 시각적으로 자신의 주인인 탐색기 **'바로 위'**에 존재해야 한다.
    * 다중 탐색기 환경에서도 [탐색기A - 메모A], [탐색기B - 메모B]의 순서가 자연스럽게 유지되어야 한다.
* **2.2.3. 시각적 동기화:**
    * 탐색기가 최소화되면 메모도 숨겨진다.
    * 탐색기가 화면에 복귀하거나 최상위로 올라오면 메모도 해당 위치에 나타난다.

---

## 3. 데이터 로직 (Data Logic)

### 3.1. 컨텍스트 기반 처리 (Context Awareness)
* **3.1.1. 즉각적 로딩:** 탐색기의 경로 변경(`EVENT_OBJECT_NAMECHANGE`) 감지 시, 지연 없이 해당 경로의 메모 데이터를 로드한다.
* **3.1.2. 데이터 소스:** 각 폴더 내의 **`folder_memo.txt`** 파일을 데이터 원본으로 사용한다.

### 3.2. 암시적 생성 및 저장 (Implicit I/O)
* **3.2.1. 상시 입력 대기:** 폴더에 파일이 없어도 항상 **빈 메모장(입력 가능 상태)**을 사용자에게 보여준다.
* **3.2.2. 트리거 생성:** 사용자가 빈 메모장에 **첫 글자를 입력하는 순간**, 해당 폴더에 `folder_memo.txt`를 자동으로 생성하고 내용을 저장한다.
* **3.2.3. 자동 저장 (Auto-Save):** 별도의 저장 버튼 없이, 내용 수정 시 실시간(또는 포커스 아웃 시) 파일에 반영한다.

---

## 4. UI/UX 및 인터랙션 (Interaction)

### 4.1. 뷰 모드 및 상태 (View States)
* **4.1.1. 기본 모드 (Default):** 탐색기 우측 하단에 적절한 크기(예: 300x400)로 상시 노출. 간단한 메모 확인 및 작성용.
* **4.1.2. 확장 모드 (Expanded):** '확장 버튼' 클릭 시, 더 넓은 화면에서 작성할 수 있도록 크기가 커진 상태.
* **4.1.3. 최소화 모드 (Minimized):** '최소화 버튼' 클릭 시, 탐색기 우측 하단 구석에 작은 바(Bar)나 아이콘 형태로 접혀 시야를 가리지 않는 상태.

### 4.2. 컨트롤 요소 (Control Elements)
* **4.2.1. 확장/축소 버튼:** [기본 모드] ↔ [확장 모드]를 토글(Toggle)한다.
* **4.2.2. 최소화 버튼 ( _ ):** 클릭 시 메모장을 [최소화 모드]로 접는다. (다시 클릭 시 복원)
* **4.2.3. 종료 버튼 ( X ):** 클릭 시 해당 메모 오버레이 프로그램을 완전히 종료한다. (탐색기는 유지)

### 4.3. 단축키 및 접근성 (Shortcuts)
* **4.3.1. 폰트 줌 (Wheel):** 메모장 위에서 `Ctrl` + `마우스 휠 업/다운` 시 폰트 크기를 확대/축소한다.
* **4.3.2. 폰트 줌 (Keyboard):** 메모장 포커스 상태에서 `Ctrl` + `+ / -` 키 입력 시 폰트 크기를 확대/축소한다.


##########################################################################################
##########################################################################################

# 1. PRD-주석 연계 개발 방법론 (PRD-Comment Linked Development)

이 방법론은 **PRD(제품 요구사항 정의서)**와 **코드 주석**을 긴밀하게 연결하여, 개발 주체(AI 또는 개발자)가 변경되더라도 문맥을 잃지 않고 일관성 있는 개발을 지속하는 것을 목표로 합니다.

### 핵심 목표
* **문맥의 연속성 보장:** 코드만 보고도 기획 의도와 변경 이력을 파악 가능하게 함
* **리소스 낭비 방지:** 불필요한 재분석 과정을 줄여 효율성 증대

### 실행 가이드
1. **계층적 PRD 작성:**
   - 모든 요구사항에 고유 번호를 부여하여 구조화합니다.
   - *예시: 1. 기능 A / 1.1. 세부 기능 A-1 / 1.1.1. 예외 처리*
2. **PRD 기반 주석 작성:**
   - 코드 주석에 해당 로직이 PRD의 어떤 번호(항목)와 연계되는지 명시합니다.
   - 단순한 코드 설명이 아닌, **'구현 의도'**를 함께 기록하여 다음 작업자가 문맥을 이해하도록 돕습니다.
3. **변경 이력의 문맥화:**
   - 코드 수정 시, '어떻게' 바꾸었는지보다 **'왜'** 바꾸었는지에 대한 문맥을 주석에 추가합니다.
   - 함수나 로직 변경 사유를 명확히 하여 히스토리를 관리합니다.

---

# 2. 선호하는 코딩 스타일 가이드라인 (My Coding Style Preferences)

저는 **'실용적 효율성'**과 **'시스템 최적화'**를 최우선 가치로 둡니다.

### 2.1. 기본 원칙
* **모듈식 코드 수정:**
  - 전체 스크립트를 다시 작성하는 것을 지양합니다.
  - 수정이 필요한 함수나 블록만 별도로 작성하여, '복사 & 붙여넣기'로 쉽게 교체할 수 있도록 합니다. (토큰 절약 및 가독성 확보)
* **친절하고 명확한 주석:**
  - AI와 인간 모두가 쉽게 이해할 수 있도록 상세하고 맥락이 있는 주석을 지향합니다.

### 2.2. 핵심 철학: 친환경적 코드 (Eco-friendly Code)
시스템 리소스를 최소화하고 OS 본연의 기능을 활용하는 4가지 핵심 키워드를 준수합니다.

| 키워드 | 핵심 개념 | 요구 사항 |
| :--- | :--- | :--- |
| **① Event-Driven Architecture**<br>(이벤트 구동형 아키텍처) | **"Polling 금지, Event 준수"**<br>주기적 검사가 아닌, 신호가 올 때만 작동합니다. | `while(true)`나 `Sleep()`을 이용한 무한 루프 감시를 금지합니다.<br>대신 Hook, Callback, Signal 방식을 사용하여 OS의 신호를 기다립니다. |
| **② Polling-Free**<br>(폴링 배제) | **"CPU 낭비 제로"**<br>상태 변화 감지를 위한 반복적인 쿼리를 제거합니다. | 타이머나 루프를 돌며 상태를 체크하는 코드를 걷어내고,<br>OS 이벤트를 수신하는 구조로 작성합니다. |
| **③ Native OS Integration**<br>(네이티브 OS 통합) | **"근본 API 활용"**<br>무거운 래퍼(Wrapper) 대신 OS 제공 API를 직접 씁니다. | 외부 라이브러리 의존도를 낮추고, 시스템 부하가 적은 가벼운 OS API(예: Win32 API, `SetWinEventHook`)를 우선 사용합니다. |
| **④ Lazy Evaluation**<br>(지연 평가) | **"필요한 순간에만 연산"**<br>실제 데이터가 필요할 때까지 실행을 미룹니다. | 미리 계산하지 않고, 특정 이벤트(예: `EVENT_SYSTEM_FOREGROUND`, `NAMECHANGE`)가 발생했을 때만 무거운 로직을 수행합니다. |

### 2.3. 기술적 목표 (Technical Goals)
* **Low Overhead (저비용 고효율):** 대기 상태 시 CPU 점유율 0% 수렴 목표.
* **Robust UX (견고한 사용자 경험):** DPI Scaling, Z-Order, 활성화 상태(Foreground) 등 OS의 엣지 케이스(Edge Case)를 완벽히 처리.


##########################################################################################
##########################################################################################

