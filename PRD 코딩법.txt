# PRD & Coding Guidelines: Folder Memo (v2.0)

## 0. 문서 개요 (Document Info)
* **목적:** Windows 파일 탐색기(Explorer)와 연동되는 오버레이 메모 애플리케이션의 기능 명세 및 개발 원칙.
* **개발 방법론:** **PRD-주석 연계 개발 (PRD-Comment Linked Development)**
    * 코드 주석에 PRD 번호(예: `2.1.3.`)와 '구현 의도(Why)'를 반드시 명시한다.

---

## 1. 프로젝트 개요 (Overview)
* **1.1. 제품 정의:** 탐색기 창에 포스트잇처럼 붙어 다니는 **폴더별 전용 메모 오버레이**.
* **1.2. 핵심 가치:**
    * **Seamless:** 탐색기와 완벽한 일체감 (위치, Z-Order 동기화).
    * **Robustness:** 탐색기의 상태(탭 분리, 로딩 중)에 영향을 주지 않는 **무중단 비동기 처리**.
    * **Eco-Friendly:** 불필요한 연산을 배제한 Event-Driven 구조 (CPU 0% 지향).

---

## 2. 핵심 동작 및 뷰 (Core Behavior & View)

### 2.1. 탐색기 인식 및 매칭 (Detection & Matching)
* **2.1.1. 대상 인식:** 실행 중인 모든 `CabinetWClass` (파일 탐색기) 윈도우를 감지 대상으로 한다.
* **2.1.2. 1:1 오버레이 매핑:** 감지된 각 탐색기 윈도우마다 독립적인 메모 오버레이 인스턴스를 매핑한다.
* **2.1.3. 비동기 신규 감지 (Async Detection):** 탐색기 생성 감지 시, 메인 스레드를 차단(Block)하지 않고 **별도 스레드**를 통해 안전하게 경로를 확인한다.
* **2.1.4. 탭(Tab) 유동성 지원:** 탭 분리/병합 등 고부하 작업 시에도 프로그램이 멈추지 않아야 한다.

### 2.2. 화면 배치 및 순서 (Layout & Z-Order)
* **2.2.1. 상대적 위치 고정 (Anchor):** 메모는 항상 탐색기 내부(Client Area) **우측 하단**에 위치하며 이동/크기 변경에 동기화된다.
* **2.2.2. 계층적 Z-Order:** 시각적으로 탐색기 **'바로 위'**에 존재하며, 다중 창 환경에서도 순서를 유지한다.
* **2.2.3. 시각적 동기화:** 탐색기의 최소화/복원/최상위 이동 상태와 동기화된다.

---

## 3. 데이터 로직 (Data Logic)

### 3.1. 컨텍스트 기반 처리 (Context Awareness)
* **3.1.1. 비동기 로딩 (Async Loading):** 경로 변경(`NAMECHANGE`) 시, 즉시 COM API를 호출하지 않고 **작업 스레드(Worker Thread)**에 위임하여 탐색기 응답 지연에 대처한다.
* **3.1.2. 데이터 소스:** 각 폴더 내의 **`folder_memo.txt`** 파일을 데이터 원본으로 사용한다.

### 3.2. 암시적 생성 및 저장 (Implicit I/O)
* **3.2.1. 상시 입력 대기:** 파일이 없어도 빈 메모장(입력 가능)을 보여준다.
* **3.2.2. 트리거 생성:** 내용 입력 시작 시 `folder_memo.txt`를 자동 생성한다.
* **3.2.3. 자동 저장 (Auto-Save):** 내용 수정 시 실시간으로 파일에 저장한다.

---

## 4. UI/UX 및 인터랙션 (Interaction)

### 4.1. 뷰 모드 및 상태
* **4.1.1. 기본/확장/최소화:** 우측 하단 상시 노출. 확장(크기 증가) 및 최소화(아이콘화) 모드 지원.

### 4.2. 컨트롤 요소
* **4.2.1. 버튼 구성:** 확장/축소(Toggle), 최소화(`_`), 종료(`X`).

### 4.3. 단축키
* **4.3.1. 폰트 줌:** `Ctrl` + `Wheel` 또는 `Ctrl` + `+/-`로 폰트 크기 조절.

---

##########################################################################################

# 2. 선호하는 코딩 스타일 가이드라인 (My Coding Style Preferences)

저는 **'실용적 효율성(Practical Efficiency)'**과 **'안정성(Robustness)'**을 최우선으로 합니다.

### 2.1. 기본 원칙
* **모듈식 수정:** 수정할 함수 단위로 코드를 제공하여 복사&붙여넣기 편의성 제공.
* **맥락적 주석:** 코드의 작동 방식뿐만 아니라, **'왜(Why)'** 이렇게 구현했는지(특히 비동기 처리 부분) 설명 필수.

### 2.2. 핵심 철학: 친환경 & 비동기 (Eco-friendly & Async)
탐색기와의 **교착 상태(Deadlock)**를 피하고 리소스를 효율적으로 쓰는 4가지 원칙입니다.

| 키워드 | 핵심 개념 | 구현 요구 사항 |
| :--- | :--- | :--- |
| **① Event-Driven**<br>(이벤트 구동) | **"신호가 올 때만 반응"** | `while(true)` 루프 금지. OS Hook(`SetWinEventHook`)을 통해 상태 변화를 감지. |
| **② Async Worker**<br>(비동기 작업자) | **"메인 스레드 보호"** | 탐색기 정보 조회(COM API)는 **절대 메인 스레드나 Hook 내부에서 직접 호출 금지.**<br>반드시 `std::thread`를 생성하여 백그라운드에서 처리. |
| **③ Robust Retry**<br>(견고한 재시도) | **"기다려주는 미덕"** | 탐색기가 바빠서(탭 분리 등) 응답이 없으면, 작업 스레드 내부에서 `sleep` 후 재시도(Retry) 로직 수행.<br>절대 프로그램이 멈추거나 죽지 않아야 함. |
| **④ Polling-Free**<br>(폴링 배제) | **"무의미한 감시 금지"** | 전역 타이머(`SetTimer`)로 감시하지 않음.<br>단, 작업 스레드 내의 일시적 재시도 대기(Wait)는 허용. |

### 2.3. 기술적 목표 (Technical Goals)
* **Non-Blocking UX:** 탐색기가 10초간 응답 없어도 내 프로그램은 멈추지 않아야 함. (비동기 필수)
* **Zombie Prevention:** 탐색기 종료 시 `EVENT_OBJECT_DESTROY`를 정확히 감지하여 즉시 오버레이 제거.
* **Native API:** 무거운 라이브러리 없이 Win32 API 위주로 가볍게 작성.


##########################################################################################
##########################################################################################

