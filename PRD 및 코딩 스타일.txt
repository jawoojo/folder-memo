
# PRD & Coding Guidelines: Folder Memo (v3.0 - Final Product Spec)

## 0. 문서 개요 (Document Info)

* **목적:** Windows 파일 탐색기(Explorer)와 연동되는 'Folder Memo' 애플리케이션의 최종 기능 명세 및 디자인 요구사항 정의.
* **문서 성격:** 기술적 구현 방식(How)보다 **제품의 기능, 디자인, 사용자 경험(What)** 정의에 집중한다.
* **개발 방법론:** **PRD-주석 연계 개발** (코드 주석에 본 문서의 번호를 참조하여 의도를 명시)

---

## 1. 프로젝트 개요 (Overview)

* **1.1. 제품 정의:** 파일 탐색기 우측 하단에 상주하며, 해당 폴더의 컨텍스트(Context)를 저장하고 보여주는 **초경량 메모 오버레이**.
* **1.2. 핵심 가치:**
* **Invisible Utility:** 사용자가 의식하지 않아도 항상 그 자리에 존재하며, 필요할 때만 시각적으로 인지됨.
* **Context-Aware:** 폴더를 이동하면 메모 내용도 자동으로 교체됨.
* **Aesthetic Minimalism:** 탐색기의 디자인을 해치지 않는 모던하고 플랫(Flat)한 디자인.



---

## 2. 디자인 및 UI 규격 (Design & UI Specifications)

### 2.1. 전체적인 룩앤필 (Look & Feel)

* **2.1.1. 색상 테마:**
* **배경색:** 눈의 피로를 최소화하고 탐색기와 조화를 이루는 **연회색 (`#F3F3F3`)**.
* **테두리:** 윈도우 기본 스타일 대신, **1px 두께의 모던 그레이 (`RGB(100,100,100)`)** 테두리 적용.


* **2.1.2. 윈도우 스타일:**
* 제목 표시줄(Title Bar)을 제거하고, 클라이언트 영역 전체를 메모 및 컨트롤 영역으로 사용.
* **반투명 효과:** 사용자가 뒷 배경을 인지할 수 있도록 약 **20~30%의 투명도** 적용.



### 2.2. 컴포넌트 디자인 (Component Design)

* **2.2.1. 컨트롤 버튼 (Flat Style):**
* 기존 Windows 3D 버튼 스타일을 배제하고, **단색 선(Line)**으로 그려진 아이콘 사용.
* **닫기(X):** 프로그램 종료.
* **확장/축소(□):** 메모 영역 크기 토글.
* **최소화(_):** 아이콘 모드로 전환.


* **2.2.2. 입력 영역 (Editor):**
* 폰트: 가독성이 좋은 **'맑은 고딕(Malgun Gothic)'**, **Bold(굵게)** 처리하여 투명도 적용 시에도 시인성 확보.
* 스크롤바: 기능은 유지하되, 시각적 방해를 최소화하도록 우측 끝에 배치.



### 2.3. 상태별 뷰 (View States)

* **2.3.1. 기본 모드 (Default):** 탐색기 우측 하단에 적절한 크기(예: 400x600)로 배치.
* **2.3.2. 최소화 모드 (Minimized):**
* 내용이 가려지고 **50x50 픽셀** 크기의 정사각형 아이콘으로 변환.
* 아이콘 디자인: 중앙에 **'▤' (메모 모양 심볼)** 배치.
* 탐색기 작업에 방해를 주지 않도록 우측 하단 구석에 밀착.



---

## 3. 기능 요구사항 (Functional Requirements)

### 3.1. 데이터 관리 및 I/O (Data Management)

* **3.1.1. 파일 매핑:** 현재 열려 있는 폴더 경로의 `folder_memo.txt` 파일과 1:1로 매핑된다.
* **3.1.2. 자동 로드 (Auto-Load):**
* 폴더 진입 시 해당 폴더에 메모 파일이 존재하면 즉시 내용을 표시한다.
* **[예외 처리]** 메모 파일이 없는 폴더 진입 시, **화면을 즉시 빈 칸으로 초기화**하여 이전 폴더의 잔상(Ghost text)을 제거한다.


* **3.1.3. 암시적 저장 (Implicit Save):** 별도의 '저장' 버튼이 존재하지 않는다. 사용자의 키 입력이 발생할 때마다 실시간으로 파일에 저장한다.
* **3.1.4. 지연 생성 (Lazy Creation):** 빈 메모장 상태에서는 파일을 생성하지 않으며, **사용자가 첫 글자를 입력하는 순간** 파일을 생성한다.

### 3.2. 사용자 인터랙션 (Interaction)

* **3.2.1. 필수 단축키 지원:**
* **`Ctrl` + `A`:** 메모장 내 전체 텍스트 선택 기능 지원 (기본 Edit 컨트롤의 미지원 기능 보완).
* **`Ctrl` + `Mouse Wheel`:** 폰트 크기 확대/축소.


* **3.2.2. 윈도우 동기화:**
* 탐색기 창 이동/크기 조절 시 오버레이도 실시간으로 따라다녀야 한다.
* 탐색기가 최소화되면 오버레이도 숨겨져야 한다.
* 탐색기가 닫히거나 숨겨지면(Hide), 오버레이는 **즉시 소멸**하여 좀비 프로세스가 되지 않아야 한다.



---

## 4. 비기능 요구사항 (Non-Functional Requirements)

### 4.1. 성능 및 효율성 (Performance)

* **4.1.1. Zero Overhead:** 사용자가 입력을 하지 않거나 탐색기를 조작하지 않는 **유휴(Idle) 상태에서는 CPU 점유율이 0%**여야 한다.
* **4.1.2. Polling Free:** 파일 유무나 윈도우 상태를 확인하기 위해 무한 루프를 돌며 검사하는 방식을 금지한다.

### 4.2. 안정성 (Robustness)

* **4.2.1. Non-Blocking:** 탐색기가 응답 없음 상태이거나 탭 분리 등의 무거운 작업 중일 때, 메모 프로그램이 같이 멈추거나 하얗게 변하지 않아야 한다.

---

##########################################################################################

# 2. 선호하는 코딩 스타일 가이드라인 (My Coding Style Preferences)

저는 **'실용적 효율성(Practical Efficiency)'**과 **'안정성(Robustness)'**을 최우선으로 합니다.

### 2.1. 기본 원칙

* **모듈식 수정:** 수정할 함수 단위로 전체 코드를 제공하여 복사&붙여넣기 편의성 제공.
* **맥락적 주석:** 코드의 작동 방식뿐만 아니라, **'왜(Why)'** 이렇게 구현했는지(특히 비동기 처리 부분) 설명 필수.

### 2.2. 핵심 철학: 친환경 & 비동기 (Eco-friendly & Async)

탐색기와의 **교착 상태(Deadlock)**를 피하고 리소스를 효율적으로 쓰는 4가지 원칙입니다.

| 키워드 | 핵심 개념 | 구현 요구 사항 |
| --- | --- | --- |
| **① Event-Driven**<br>

<br>(이벤트 구동) | **"신호가 올 때만 반응"** | `while(true)` 루프 금지. OS Hook(`SetWinEventHook`)을 통해 상태 변화를 감지. |
| **② Async Worker**<br>

<br>(비동기 작업자) | **"메인 스레드 보호"** | 탐색기 정보 조회(COM API)는 **절대 메인 스레드나 Hook 내부에서 직접 호출 금지.**<br>

<br>반드시 `std::thread`를 생성하여 백그라운드에서 처리. |
| **③ Robust Retry**<br>

<br>(견고한 재시도) | **"기다려주는 미덕"** | 탐색기가 바빠서(탭 분리 등) 응답이 없으면, 작업 스레드 내부에서 `sleep` 후 재시도(Retry) 로직 수행.<br>

<br>절대 프로그램이 멈추거나 죽지 않아야 함. |
| **④ Polling-Free**<br>

<br>(폴링 배제) | **"무의미한 감시 금지"** | 전역 타이머(`SetTimer`)로 감시하지 않음.<br>

<br>단, 작업 스레드 내의 일시적 재시도 대기(Wait)는 허용. |

### 2.3. 기술적 목표 (Technical Goals)

* **Non-Blocking UX:** 탐색기가 10초간 응답 없어도 내 프로그램은 멈추지 않아야 함. (비동기 필수)
* **Zombie Prevention:** 탐색기 종료 시 `EVENT_OBJECT_DESTROY`를 정확히 감지하여 즉시 오버레이 제거.
* **Native API:** 무거운 라이브러리 없이 Win32 API 위주로 가볍게 작성.

##########################################################################################
##########################################################################################