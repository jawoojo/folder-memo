ë¬¸ì œ
    ì‹¤í–‰í•˜ë©´ ë ‰ì´ ì—„ì²­ ê±¸ë¦¼ ë­”ê°€ ì—„ì²­ ë²„ë²…ì„.
    ì•„ë¬´ë˜ë„ í´ë” ìœ„ì¹˜ë¥¼ ê³„ì† ì¶”ì²™í•˜ëŠ” ê³¼ì •ì—ì„œ ë²„ë²…ì´ëŠ” ê²ƒ ê°™ìŒ.
        ì¼ë‹¨ ì™œ ë²„ë²…ì´ëŠ”ì§€ í™•ì¸í•´ë³´ì.
    ë‹«ê¸° ë²„íŠ¼ì´ ì—†ì–´ì„œ ëŒ ìˆ˜ê°€ ì—†ìŒ.
        ë„ê¸° ë²„íŠ¼ë„ ë„£ì.



        // ğŸ‘‡ ìœ ë‹ˆì½”ë“œ ë° ë¼ì´ë¸ŒëŸ¬ë¦¬ ì„¤ì •
#include <dwmapi.h> // DwmGetWindowAttribute ì‚¬ìš©ì„ ìœ„í•´ í•„ìš” (í—¤ë” ìƒë‹¨ì— ì¶”ê°€)
#pragma comment(lib, "dwmapi.lib") // ë¼ì´ë¸ŒëŸ¬ë¦¬ ë§í¬ (í—¤ë” ìƒë‹¨ì— ì¶”ê°€)

#define UNICODE
#define _UNICODE

#include <windows.h>
#include <vector>
#include <string>
#include <iostream>
#include <fstream>
#include <codecvt>
#include <UIAutomation.h>
#include <comdef.h>

#pragma comment(lib, "ole32.lib")
#pragma comment(lib, "oleaut32.lib")
#pragma comment(lib, "gdi32.lib")
#pragma comment(lib, "uuid.lib")

// --- ì „ì—­ ë³€ìˆ˜ ---
IUIAutomation* g_pAutomation = NULL;
HWINEVENTHOOK g_hHook = NULL; // ìœˆë„ìš° ì´ë™ ê°ì§€ í›… í•¸ë“¤

struct OverlayPair {
    HWND hExplorer;       // íƒ€ê²Ÿ íƒìƒ‰ê¸°
    HWND hOverlay;        // ë‚´ ë©”ëª¨ì¥
    std::wstring currentPath;
    DWORD lastPathCheckTick;
};
std::vector<OverlayPair> g_overlays;

const wchar_t CLASS_NAME[] = L"ExplorerMemoOverlayClass";
const int OVERLAY_WIDTH = 250;
const int OVERLAY_HEIGHT = 200; // ë©”ëª¨ì¥ì´ë‹ˆ ë„ˆë¬´ í¬ì§€ ì•Šê²Œ

// --- (ê¸°ì¡´ íŒŒì¼ ì…ì¶œë ¥ í•¨ìˆ˜ë“¤ì€ ê·¸ëŒ€ë¡œ ìœ ì§€) ---
// LoadMemo, SaveMemo í•¨ìˆ˜ëŠ” ê¸°ì¡´ ì½”ë“œë¥¼ ê·¸ëŒ€ë¡œ ì‚¬ìš©í•˜ì„¸ìš”.
// (ì§€ë©´ ê´€ê³„ìƒ ìƒëµí•˜ì§€ë§Œ, ì‹¤ì œ ì½”ë“œì—ëŠ” í¬í•¨ë˜ì–´ì•¼ í•©ë‹ˆë‹¤)
std::wstring LoadMemo(const std::wstring& folderPath) { /* ê¸°ì¡´ ì½”ë“œ */ return L""; }
void SaveMemo(const std::wstring& folderPath, const std::wstring& content) { /* ê¸°ì¡´ ì½”ë“œ */ }

// --- ì˜¤ë²„ë ˆì´ ìœˆë„ìš° í”„ë¡œì‹œì € ---
LRESULT CALLBACK WindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam) {
    switch (uMsg) {
    case WM_CREATE: {
        // ë©”ëª¨ì¥(ì—ë””íŠ¸ ì»¨íŠ¸ë¡¤) ìƒì„±
        CreateWindowW(L"EDIT", NULL,
            WS_CHILD | WS_VISIBLE | WS_VSCROLL | ES_LEFT | ES_MULTILINE | ES_AUTOVSCROLL,
            0, 0, 0, 0, hwnd, (HMENU)101, (HINSTANCE)GetWindowLongPtr(hwnd, GWLP_HINSTANCE), NULL);
        
        // í°íŠ¸ ì„¤ì •
        HFONT hFont = CreateFontW(16, 0, 0, 0, FW_NORMAL, FALSE, FALSE, FALSE, DEFAULT_CHARSET, OUT_DEFAULT_PRECIS, CLIP_DEFAULT_PRECIS, DEFAULT_QUALITY, DEFAULT_PITCH | FF_SWISS, L"Malgun Gothic");
        SendDlgItemMessage(hwnd, 101, WM_SETFONT, (WPARAM)hFont, TRUE);
        return 0;
    }
    case WM_SIZE: {
        RECT rc;
        GetClientRect(hwnd, &rc);
        // íƒ€ì´í‹€ë°” ì˜ì—­(25px) ì œì™¸í•˜ê³  ì—ë””í„° ì±„ìš°ê¸°
        HWND hEdit = GetDlgItem(hwnd, 101);
        MoveWindow(hEdit, 0, 25, rc.right, rc.bottom - 25, TRUE);
        return 0;
    }
    case WM_PAINT: {
        PAINTSTRUCT ps;
        HDC hdc = BeginPaint(hwnd, &ps);
        
        // íƒ€ì´í‹€ë°” ì˜ì—­ ê·¸ë¦¬ê¸° (ë“œë˜ê·¸ í•¸ë“¤ ì—­í• )
        RECT rcTitle = { 0, 0, OVERLAY_WIDTH, 25 };
        HBRUSH brush = CreateSolidBrush(RGB(230, 230, 230)); // ì—°í•œ íšŒìƒ‰
        FillRect(hdc, &rcTitle, brush);
        DeleteObject(brush);

        // í˜„ì¬ ê²½ë¡œ í‘œì‹œ
        SetBkMode(hdc, TRANSPARENT);
        std::wstring msg = L"";
        for (const auto& pair : g_overlays) {
            if (pair.hOverlay == hwnd) {
                msg = pair.currentPath.empty() ? L"ê²½ë¡œ ì—†ìŒ" : pair.currentPath;
                break;
            }
        }
        TextOutW(hdc, 5, 5, msg.c_str(), msg.length());
        
        EndPaint(hwnd, &ps);
        return 0;
    }
    // (WM_COMMAND ë“± ì €ì¥ ë¡œì§ì€ ê¸°ì¡´ ì½”ë“œ í™œìš©)
    }
    return DefWindowProc(hwnd, uMsg, wParam, lParam);
}


void SyncOverlayPosition(const OverlayPair& pair) {
    if (!IsWindow(pair.hExplorer)) return;

    RECT rcExp;
    // ìœˆë„ìš° 10/11ì˜ íˆ¬ëª…í•œ ê·¸ë¦¼ì ì˜ì—­ì„ ì œì™¸í•œ 'ì‹¤ì œ ëˆˆì— ë³´ì´ëŠ” í…Œë‘ë¦¬' ì¢Œí‘œë¥¼ ê°€ì ¸ì˜µë‹ˆë‹¤.
    HRESULT res = DwmGetWindowAttribute(pair.hExplorer, DWMWA_EXTENDED_FRAME_BOUNDS, &rcExp, sizeof(rcExp));
    
    // ë§Œì•½ Dwm í•¨ìˆ˜ê°€ ì‹¤íŒ¨í•˜ë©´(êµ¬ë²„ì „ ìœˆë„ìš° ë“±), ì¼ë°˜ GetWindowRectë¥¼ ì”ë‹ˆë‹¤.
    if (res != S_OK) {
        GetWindowRect(pair.hExplorer, &rcExp);
    }

    // â­ ìœ„ì¹˜ ê³„ì‚°: íƒìƒ‰ê¸° "ì˜¤ë¥¸ìª½ í•˜ë‹¨" êµ¬ì„
    // X ì¢Œí‘œ = íƒìƒ‰ê¸° ìš°ì¸¡ ë(Right) - ì˜¤ë²„ë ˆì´ ë„ˆë¹„ - ì—¬ë°±(ìŠ¤í¬ë¡¤ë°” ê³ ë ¤ 25px)
    int x = rcExp.right - OVERLAY_WIDTH - 25; 
    
    // Y ì¢Œí‘œ = íƒìƒ‰ê¸° ë°”ë‹¥(Bottom) - ì˜¤ë²„ë ˆì´ ë†’ì´ - ì—¬ë°±(10px)
    int y = rcExp.bottom - OVERLAY_HEIGHT - 10; 

    // í™”ë©´ ë°–ìœ¼ë¡œ ë‚˜ê°€ëŠ” ê²½ìš° ë°©ì§€ (ì„ íƒ ì‚¬í•­)
    // if (x < rcExp.left) x = rcExp.left; 

    // ìœ„ì¹˜ ì ìš©
    // SWP_NOACTIVATE: ë©”ëª¨ì¥ì´ í¬ì»¤ìŠ¤ë¥¼ ëºì–´ì„œ íƒìƒ‰ê¸° ì°½ì´ ë¹„í™œì„±í™”ë˜ëŠ” ê²ƒì„ ë°©ì§€
    // SWP_NOZORDER: Zìˆœì„œ(ì•ë’¤ ê´€ê³„)ëŠ” ê±´ë“œë¦¬ì§€ ì•ŠìŒ (ê¹œë¹¡ì„ ë°©ì§€)
    SetWindowPos(pair.hOverlay, HWND_TOPMOST, x, y, OVERLAY_WIDTH, OVERLAY_HEIGHT, 
                 SWP_NOACTIVATE | SWP_NOSIZE | SWP_NOREDRAW);
    
    // ê°•ì œë¡œ ë‹¤ì‹œ ê·¸ë ¤ì„œ ì”ìƒì„ ì—†ì•±ë‹ˆë‹¤.
    // RedrawWindow(pair.hOverlay, NULL, NULL, RDW_INVALIDATE | RDW_UPDATENOW); 
}

// --- ì´ë²¤íŠ¸ í›… ì½œë°± í•¨ìˆ˜ (OSê°€ í˜¸ì¶œí•¨) ---
void CALLBACK WinEventProc(HWINEVENTHOOK hWinEventHook, DWORD event, HWND hwnd, 
                           LONG idObject, LONG idChild, DWORD dwEventThread, DWORD dwmsEventTime) {
    
    // ìœˆë„ìš°ê°€ ì´ë™í–ˆê±°ë‚˜(LOCATIONCHANGE), í¬ê¸°ê°€ ë³€í–ˆê±°ë‚˜, ìµœì†Œ/ìµœëŒ€í™” ë¨
    if (event == EVENT_OBJECT_LOCATIONCHANGE && idObject == OBJID_WINDOW) {
        // ì›€ì§ì¸ ìœˆë„ìš°(hwnd)ê°€ ìš°ë¦¬ê°€ ê´€ë¦¬í•˜ëŠ” íƒìƒ‰ê¸°ì¸ì§€ í™•ì¸
        for (auto& pair : g_overlays) {
            if (pair.hExplorer == hwnd) {
                SyncOverlayPosition(pair);
                return; // ì°¾ì•˜ìœ¼ë©´ ì²˜ë¦¬í•˜ê³  ì¢…ë£Œ
            }
        }
    }
}

// --- UI Automation ê²½ë¡œ ê°€ì ¸ì˜¤ê¸° (ê¸°ì¡´ í•¨ìˆ˜ ìœ ì§€) ---
std::wstring GetExplorerPath(HWND hExplorer) { /* ê¸°ì¡´ GetExplorerPath í•¨ìˆ˜ ë‚´ìš© */ return L""; }

// --- ì£¼ê¸°ì  ê´€ë¦¬ (ìƒˆ íƒìƒ‰ê¸° ê°ì§€ ë° ê²½ë¡œ ì—…ë°ì´íŠ¸) ---
// ìœ„ì¹˜ ì´ë™ì€ 'í›…'ìœ¼ë¡œ ì²˜ë¦¬í•˜ì§€ë§Œ, 'ìƒˆë¡œìš´ íƒìƒ‰ê¸°ê°€ ì¼œì§€ëŠ” ê²ƒ'ê³¼ 'í´ë” ì´ë™'ì€ íƒ€ì´ë¨¸ë¡œ ì²´í¬í•˜ëŠ” ê²Œ ì•ˆì „í•¨
void ManageOverlays(HINSTANCE hInstance) {
    // 1. ì£½ì€ íƒìƒ‰ê¸° ì •ë¦¬
    for (auto it = g_overlays.begin(); it != g_overlays.end(); ) {
        if (!IsWindow(it->hExplorer)) {
            DestroyWindow(it->hOverlay);
            it = g_overlays.erase(it);
        } else {
            ++it;
        }
    }

    // 2. ìƒˆë¡œìš´ íƒìƒ‰ê¸° ì°¾ê¸°
    // (EnumWindows ëŒ€ì‹  FindWindowExë¡œ ê°„ë‹¨íˆ ì˜ˆì‹œ, ì‹¤ì œë¡  EnumWindowsê°€ ë” ì •í™•í•  ìˆ˜ ìˆìŒ)
    HWND hCur = FindWindowW(L"CabinetWClass", NULL);
    while (hCur) {
        bool managed = false;
        for (const auto& pair : g_overlays) {
            if (pair.hExplorer == hCur) { managed = true; break; }
        }
        
        if (!managed && IsWindowVisible(hCur)) {
            // ìƒˆ ì˜¤ë²„ë ˆì´ ìƒì„±
            HWND hNew = CreateWindowEx(WS_EX_TOOLWINDOW | WS_EX_TOPMOST | WS_EX_LAYERED, 
                CLASS_NAME, L"Memo", WS_POPUP | WS_VISIBLE, 0, 0, OVERLAY_WIDTH, OVERLAY_HEIGHT, 
                NULL, NULL, hInstance, NULL);
            
            // íˆ¬ëª…ë„ ì‚´ì§ ì¤˜ì„œ ë” ìì—°ìŠ¤ëŸ½ê²Œ (ì˜µì…˜)
            SetLayeredWindowAttributes(hNew, 0, 240, LWA_ALPHA);

            if (hNew) {
                OverlayPair p = { hCur, hNew, L"", 0 };
                g_overlays.push_back(p);
                SyncOverlayPosition(p); // ìƒì„± ì¦‰ì‹œ ìœ„ì¹˜ ì¡ê¸°
            }
        }
        hCur = FindWindowExW(NULL, hCur, L"CabinetWClass", NULL);
    }

    // 3. ê²½ë¡œ ì—…ë°ì´íŠ¸ (í´ë” ì´ë™ ê°ì§€) - 0.5ì´ˆë§ˆë‹¤
    DWORD dwNow = GetTickCount();
    for (auto& pair : g_overlays) {
        if (dwNow - pair.lastPathCheckTick > 500) {
            pair.lastPathCheckTick = dwNow;
            // UI Automationì€ ë¬´ê±°ìš°ë¯€ë¡œ ì—¬ê¸°ì„œë§Œ í˜¸ì¶œ
            std::wstring path = GetExplorerPath(pair.hExplorer); 
            if (!path.empty() && path != pair.currentPath) {
                pair.currentPath = path;
                // ë©”ëª¨ ë¡œë”© ë¡œì§...
                SetWindowText(GetDlgItem(pair.hOverlay, 101), LoadMemo(path).c_str());
            }
            
            // í˜¹ì‹œ í›…ì´ ë†“ì³¤ì„ ê²½ìš°ë¥¼ ëŒ€ë¹„í•´ ìœ„ì¹˜ í•œë²ˆ ë” ë³´ì •
            SyncOverlayPosition(pair); 
        }
    }
}

int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE, LPSTR, int) {
    CoInitializeEx(NULL, COINIT_MULTITHREADED);
    // (UIAutomation ì´ˆê¸°í™” ì½”ë“œ ìƒëµ - í•„ìˆ˜!)
    
    // ìœˆë„ìš° í´ë˜ìŠ¤ ë“±ë¡
    WNDCLASSW wc = { 0 };
    wc.lpfnWndProc = WindowProc;
    wc.hInstance = hInstance;
    wc.lpszClassName = CLASS_NAME;
    wc.hbrBackground = (HBRUSH)GetStockObject(WHITE_BRUSH);
    wc.hCursor = LoadCursor(NULL, IDC_ARROW);
    RegisterClassW(&wc);

    // â­ í•µì‹¬: ìœˆë„ìš° ì´ë²¤íŠ¸ í›… ì„¤ì¹˜
    // EVENT_OBJECT_LOCATIONCHANGE: ì°½ì´ ì´ë™í•˜ê±°ë‚˜ í¬ê¸°ê°€ ë³€í•  ë•Œ ì•Œë¦¼ ìˆ˜ì‹ 
    g_hHook = SetWinEventHook(
        EVENT_OBJECT_LOCATIONCHANGE, EVENT_OBJECT_LOCATIONCHANGE, // ë²”ìœ„
        NULL, WinEventProc, 0, 0, 
        WINEVENT_OUTOFCONTEXT | WINEVENT_SKIPOWNPROCESS);

    // ë©”ì‹œì§€ ë£¨í”„ (íƒ€ì´ë¨¸ëŠ” ê²½ë¡œ í™•ì¸ìš©ìœ¼ë¡œ 0.5ì´ˆ ì •ë„ë¡œ ëŠìŠ¨í•˜ê²Œ)
    SetTimer(NULL, 1, 500, NULL); 

    MSG msg;
    while (GetMessage(&msg, NULL, 0, 0)) {
        if (msg.message == WM_TIMER) {
            ManageOverlays(hInstance);
        }
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }

    if (g_hHook) UnhookWinEvent(g_hHook);
    CoUninitialize();
    return 0;
}