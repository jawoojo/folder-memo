[C++ 윈도우 프로그래밍 성능 최적화 학습 노트]

이 문서는 '메모장 오버레이 프로그램'을 개발하면서 발생한 성능 문제(버벅임, CPU 과부하)를 해결하기 위해 적용된 기술들을 정리한 노트입니다.

1. 무한 루프(Polling)를 이벤트 훅(Event Hook)으로 대체
   - 문제점: 기존에는 `while` 루프나 `SetTimer`로 0.01초마다 탐색기 위치를 계속 물어봤음. 탐색기가 가만히 있어도 CPU를 계속 사용함.
   - 해결책: `SetWinEventHook` API 사용.
   - 원리: "운영체제야, 창이 움직이면(EVENT_OBJECT_LOCATIONCHANGE) 나한테 알려줘"라고 등록함.
   - 효과: 창이 움직일 때만 코드가 실행되므로, 가만히 있을 때는 CPU 사용량이 0%에 수렴함.

2. 멀티스레딩(Multi-threading)을 통한 UI 버벅임 제거
   - 문제점: `UI Automation` 기능(탐색기 주소창 읽기)은 처리 속도가 매우 느림(수십~수백 ms). 이를 메인 스레드(UI 스레드)에서 실행하면, 그 시간 동안 화면이 멈추거나 마우스 입력을 못 받음.
   - 해결책: `std::thread`를 사용하여 무거운 작업을 별도 스레드로 분리.
   - 구조:
     * 메인 스레드: 창 이동, 화면 그리기 등 가벼운 작업만 전담 (부드러움 유지).
     * 백그라운드 스레드: 0.5초마다 탐색기 주소를 읽어오는 무거운 작업 전담.
   - 통신: 백그라운드 스레드가 주소 변경을 감지하면 `PostMessage`로 메인 스레드에게 "화면 갱신해!"라고 신호를 보냄.

3. 스레드 동기화 (Mutex)
   - 문제점: 메인 스레드와 백그라운드 스레드가 `g_overlays`라는 같은 변수(데이터)를 동시에 건드리면 프로그램이 뻗어버림(Race Condition).
   - 해결책: `std::mutex` 사용.
   - 원리: "나 지금 데이터 쓰고 있으니까 내가 다 쓸 때까지 아무도 건드리지 마"라고 자물쇠를 거는 것. `std::lock_guard`를 사용하여 안전하게 보호.

4. 정확한 창 크기 계산 (DwmGetWindowAttribute)
   - 문제점: 윈도우 10/11은 창 테두리에 투명한 그림자가 있어서, 일반 `GetWindowRect`로 좌표를 구하면 눈에 보이는 것보다 더 크게 잡힘(공중에 뜬 느낌).
   - 해결책: `DwmGetWindowAttribute` 함수에 `DWMWA_EXTENDED_FRAME_BOUNDS` 옵션을 사용하여 그림자를 제외한 '실제 눈에 보이는 창 크기'를 구함.

[핵심 코드 요약]
- SetWinEventHook(...): 윈도우 이벤트 감지 등록
- std::thread t(Function): 별도 일꾼(스레드) 고용
- std::lock_guard<std::mutex> lock(mutex): 데이터 충돌 방지 자물쇠
- PostMessage(...): 스레드 간 비동기 메시지 전달
