# PRD



---

# [General Guideline] PRD-Comment Driven Development (PCDD)

## 0. 가이드라인 목적 (Objective)

* **맥락의 영속성 (Context Persistence):** AI 모델이 변경되거나 세션이 초기화되어도, **PRD(요구사항)**와 **Code(구현)**의 연결고리(주석)를 통해 즉시 프로젝트의 맥락을 이해하고 개발을 이어간다.
* **리소스 절약:** 불필요한 상황 설명이나 히스토리 요약을 생략하여 토큰 소모를 최소화한다.
* **추적 가능성:** 코드의 특정 로직이 "왜" 존재하는지 PRD를 통해 역추적한다.

---

## 1. PRD 작성 표준 (PRD Writing Standards)

PRD는 제품의 **WHAT (무엇을 만들 것인가)**을 정의합니다. 코드는 **HOW (어떻게 구현할 것인가)**를 담당합니다.

### 1.1. 넘버링 시스템 (Numbering System)

모든 요구사항은 고유한 **ID(번호)**를 가져야 합니다. 코드가 이 번호를 참조(Reference)하기 때문입니다.

* **포맷:** `[섹션].[서브섹션].[항목]` (예: `3.1.2`)
* **작성 예시:**
```markdown
## 3. 기능 요구사항 (Functional Requirements)
### 3.1. 데이터 저장
* **3.1.1.** 사용자가 입력을 멈추면 0.5초 뒤 자동 저장한다.
* **3.1.2.** 저장 실패 시 트레이 아이콘에 경고 표시를 띄운다.

```



### 1.2. 기술 독립적 서술 (Tech-Agnostic)

* **권장:** "사용자가 버튼을 누르면 데이터가 갱신되어야 한다." (기능 중심)
* **지양:** "`OnClick` 이벤트에서 `UpdateData()` 함수를 호출한다." (구현 디테일은 코드의 영역)

---

## 2. 코드 주석 작성 표준 (Comment Standards)

주석은 코드를 설명하는 것이 아니라, **PRD와의 연결고리**이자 **구현의 의도(Context)**를 설명해야 합니다.

### 2.1. 기본 포맷

```cpp
// [PRD 번호] 요약된 요구사항 명칭
// - 구현 의도: 왜 이렇게 짰는가? (Why)
// - 기술적 결정: 트레이드오프나 제약사항 (Constraints)
// - 예외 처리: 특이 사항 (Edge Case)

```

### 2.2. 작성 예시 (Bad vs Good)


네, 이전 양식(`구현 의도`, `기술적 결정`, `예외 처리`를 매번 명시)은 간단한 프로젝트에서는 너무 무거울 수 있습니다.

**"가장 핵심적인 것(ID + What + Why)"**만 남겨서, **한 줄에서 두 줄로 끝낼 수 있는 '범용적이고 가벼운 포맷'**으로 다시 정리해 드립니다.

복사해서 바로 사용하세요.

---

# [Global Guideline] PRD-Context Driven Development (Lite Version)

## 1. 핵심 철학 (Philosophy)

* **Goal:** AI가 바뀌어도 **PRD(문서)**와 **주석(코드)**만 보면 프로젝트의 흐름(Context)을 완벽히 복원할 수 있어야 한다.
* **Rule:** 코드는 `HOW`를 말하고, 주석은 `PRD ID`와 `WHY(맥락)`를 말한다.

---

## 2. PRD 작성 표준 (PRD Standards)

* **넘버링 필수:** 모든 요구사항에는 고유 번호(ID)가 있어야 한다.
* **What 중심:** 기술적 구현 방법이 아닌, **'기능'과 '목표'** 위주로 서술한다.

> **작성 예시:**
> * **[3.1]** 자동 저장 기능: 사용자가 입력을 멈추면 1초 뒤에 파일에 저장한다.
> 
> 

---

## 3. 코드 주석 표준 (Comment Standards) : 🔥 핵심 수정됨

복잡한 형식을 버리고 **`[ID] 무엇을(What) -> 왜(Why)`** 구조를 기본으로 합니다.

### 3.1. 기본 포맷 (General Format)

가장 권장하는 간단하고 강력한 포맷입니다.

```cpp
// [PRD 번호] <기능 요약>
// -> <맥락/의도: 왜 이렇게 짰는지, 어떤 이슈를 해결했는지 한 줄 요약>

```

### 3.2. 상황별 적용 예시

**Type A. 한 줄 처리 (간단한 로직)**

* 옆에 붙여서 `ID`와 `이유`만 명시합니다.

```cpp
SetWindowText(hEdit, L""); // [PRD 2.1] 잔상 제거 -> 폴더 이동 시 기존 메모 즉시 초기화

```

**Type B. 블록 처리 (함수/클래스 단위)**

* 함수 위에는 `What`과 `Why`를 명확히 적습니다.

```cpp
// [PRD 4.3] 마우스 휠 폰트 줌
// -> 오버레이가 부모 창이라 메시지를 먼저 가로채므로, Ctrl 키 확인 후 직접 처리함.
case WM_MOUSEWHEEL: {
    // ... 코드 ...
}

```

**Type C. 비동기/복잡한 로직 (중요)**

* AI가 가장 헷갈려하는 부분이므로 `Flow(흐름)`를 간단히 언급합니다.

```cpp
// [PRD 3.1.1] 비동기 경로 탐색 (Async Pathfinder)
// -> 메인 UI 멈춤 방지(Non-Blocking)를 위해 별도 스레드 사용.
// -> Flow: 스레드 시작 -> 탐색기 핸들 검사 -> (실패 시 Retry) -> 결과 보고(PostMessage)
void PathFinderThread(...) {
    // ... 코드 ...
}


```

---

## 3. 선호하는 코딩 스타일 (Preferred Coding Style)

다음은 프로젝트 전반에 적용되어야 할 기술적 지향점입니다.

### 3.1. 친환경 & 고효율 (Eco-Friendly & High Performance)

* **Polling-Free:** `while(true)`나 `Sleep()`으로 상태를 무한 감시하는 것을 금지합니다.
* **Event-Driven:** OS나 프레임워크가 주는 **이벤트(Signal)**에만 반응하여 CPU 점유율을 **0%**로 유지합니다.
* **Native & Light:** 무거운 프레임워크보다는 Native API(Win32 등)나 가벼운 라이브러리를 선호합니다.

### 3.2. 비동기 & 안정성 (Async & Robustness)

* **Non-Blocking:** UI 스레드는 절대 멈추면 안 됩니다. I/O나 대기 시간(Network/File)이 필요한 작업은 반드시 **Worker Thread**로 위임합니다.
* **Graceful Failure:** 외부 요인(탐색기 종료, 네트워크 끊김)으로 인해 프로그램이 비정상 종료(Crash)되지 않도록 방어 코드를 작성합니다.

### 3.3. 모듈화 (Modularity for AI)

* **Copy-Paste Friendly:** AI가 코드를 수정해 줄 때, 전체 파일을 다시 짜지 않고 **"수정된 함수 단위"**로 복사해서 붙여넣기 쉽도록 함수를 독립적으로 구성합니다.

---

## 4. AI 협업 워크플로우 (Workflow with AI)

1. **PRD 제공:** 사용자가 프로젝트의 `PRD.md` 내용을 먼저 제공합니다.
2. **구현 요청:** "PRD 2.1.3 항목을 구현해줘"라고 요청합니다.
3. **코드 생성:** AI는 위 **[2. 코드 주석 작성 표준]**에 맞춰 주석이 달린 코드를 생성합니다.
4. **피드백 및 수정:** 코드가 수정되면 주석의 내용(구현 의도 등)도 함께 업데이트되어야 합니다.

---